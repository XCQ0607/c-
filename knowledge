变量命名规则(标识符，方法名)
 1.变量名只能是字母（A-Z，a-z）和数字（0-9）或者下划线（_）组成。   
 2.变量名不能以数字开头，第一个字母必须是字母或者下划线开头
 3.变量名区分大小写
 4.变量名称不能是关键字，以免冲突。例如，int是用于表示整数的关键字。
 5.变量名可以以下划线开头。但是，这不是一个好习惯。

 整数类型（Integer Types）：
int：用于表示整数，通常占用4个字节。
short：用于表示短整数，通常占用2个字节。
long：用于表示长整数，通常占用4个字节。
long long：用于表示更长的整数，通常占用8个字节。
浮点类型（Floating-Point Types）：
float：用于表示单精度浮点数，通常占用4个字节。
double：用于表示双精度浮点数，通常占用8个字节。
long double：用于表示更高精度的浮点数，占用字节数可以根据实现而变化。
字符类型（Character Types）：
char：用于表示字符，通常占用1个字节。
wchar_t：用于表示宽字符，通常占用2或4个字节。       short int
char16_t：用于表示16位Unicode字符，占用2个字节。
char32_t：用于表示32位Unicode字符，占用4个字节。
布尔类型（Boolean Type）：
bool：用于表示布尔值，只能取true或false。
枚举类型（Enumeration Types）：
enum：用于定义一组命名的整数常量。
指针类型（Pointer Types）：
type*：用于表示指向类型为type的对象的指针。
数组类型（Array Types）：
type[]或type[size]：用于表示具有相同类型的元素组成的数组。
结构体类型（Structure Types）：
struct：用于定义包含多个不同类型成员的结构。
类类型（Class Types）：
class：用于定义具有属性和方法的自定义类型。
共用体类型（Union Types）：
union：用于定义一种特殊的数据类型，它可以在相同的内存位置存储不同的数据类型。
在 C++ 中，类型的长度（即占用的字节数）取决于编译器和计算机架构，然而，C++ 标准规定了不同整数类型的最小范围，而不是具体的字节数，这是为了确保代码在不同的系统上都能正确运行。
请注意，以上类型的范围只是 C++ 标准规定的最小要求，实际上，许多系统上这些类型可能占用更多的字节，例如，很多现代计算机上 int 通常占用 4 字节，而 long 可能占用 8 字节。


变量的类型间是可以互相转换的，转换又分为自动转换和强制转换。

自动转换规则：
1、若参与运算量的类型不同，则先转换成同一类型，然后进行运算。
2、转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算。     a、若两种类型的字节数不同，转换成字节数高的类型     b、若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型
3、所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。
4、char型和short型参与运算时，必须先转换成int型。
5、在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度:


static 全局变量:改变作用范围，不改变存储位置
static 局部变量：改变存储位置，不改变作用范围
静态函数 ：在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。
如果在一个源文件中定义的函数，只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用，这种函数也称为内部函数。定义一个内部函数，只需在函数类型前再加一个“static”关键字即可。

字符 '0' 和 '\0' 及整数 0 的区别
字符型变量用于存储一个单一字符，在 C 语言中用 char 表示，其中每个字符变量都会占用 1 个字节（8 位二进制数）。
整型 int 在内存中占用空间为四个字节（32位二进制数）。
字符 '0'：char c = '0'; 它的 ASCII 码实际上是 48，内存中存放表示：00110000。
字符 '\0'： ASCII 码为 0，表示一个字符串结束的标志。这是转义字符（整体视为一个字符）。由于内存中存储字符，依然是存储的是对应字符集的字符编码，所以内存中的表现形式为 00000000。
整数 0 ： 内存中表示为 00000000 00000000 00000000 00000000，虽然都是 0，但是跟上面字符 '\0' 存储占用长度是不一样的。

转义序列码
\\	\ 字符
\'	' 字符
\"	" 字符
\?	? 字符
\a	警报铃声
\b	退格键
\f	换页符
\n	换行符
\r	回车
\t	水平制表符      相当于Tab
\v	垂直制表符
\ooo	一到三位的八进制数
\xhh . . .	一个或多个数字的十六进制数

const 修饰 *p，指向的对象只读，指针的指向可变：
const int *p = &a;//p是一个指向int类型的const值,与int const *p等价
const的int*类型指针(针对内容，指向的对象不变)
*p = 11;    //编译错误，指向的对象是只读的，不可通过p进行改变
p = &b;     //合法，改变了p的指向
const 修饰 p，指向的对象可变，指针的指向不可变：
int a = 9;
int b = 10;
int * const p = &a;//p是一个const指针
int*类型的指针指向const p(针对指针，p指向不变)
*p = 11;    //合法，
p = &b;     //编译错误，p是一个const指针，只读，不可变
const 右边修饰谁，就说明谁是不可变的。


1. 类的定义和声明
在 C++ 中，class 关键字用于定义一个类，后面跟着类的名称（这里是 A）。类的定义可以包括数据成员（称为字段或属性）和成员函数（类中的方法）。例如：
class A {
public:
    // 成员函数声明
    void method1();
    int method2(int x);

    // 数据成员
    int data;
    double another_data;
};
在上面的示例中：
class A { ... }; 表示类 A 的定义开始和结束。
public: 是访问说明符（access specifier），它定义了紧随其后的成员的访问权限。public: 意味着接下来的成员可以在类的外部被访问。
2. 成员函数
类中的函数称为成员函数。它们可以被类的对象调用，访问对象的数据成员，以及执行特定的操作。例如，上面的 method1() 和 method2(int x) 就是成员函数的声明。
3. 数据成员
类中的数据成员是类的对象的一部分，用于存储对象的状态信息。在上面的例子中，int data; 和 double another_data; 是两个数据成员的声明。
4. 访问控制
public:、private: 和 protected: 是 C++ 中的三种访问控制关键字。
public: 表示接下来的成员（包括函数和数据成员）可以在类的外部访问。这是一种最常用的访问控制方式，用于定义类的公共接口。
private: 表示接下来的成员只能在类的内部访问，外部无法直接访问。这种方式用于隐藏类的实现细节，提高封装性。
protected: 类似于 private:，但允许派生类（子类）访问这些成员。这种访问控制用于实现继承的概念。





C++ 标准库中的 functional 头文件提供了一组函数对象（或者称为函数子类型）的类模板，这些函数对象可以用作函数指针的替代，或者可以作为参数传递给标准库中的算法。让我们详细讲解几个常用的函数对象及其用途：

1. std::function
std::function 是一个通用的函数封装器，可以用来包装任何可以调用的目标：函数、函数指针、成员函数指针、lambda 表达式等。它提供了一种类型安全的方式来存储、复制、和调用可调用对象。例如：
void foo(int x) {
    std::cout << "foo: " << x << std::endl;
}

int main() {
    std::function<void(int)> func = foo;
    func(42); // 调用 foo 函数
    
    func = [](int x) { std::cout << "lambda: " << x << std::endl; };
    func(10); // 调用 lambda 表达式
    
    return 0;
}
2. std::bind
std::bind 可以创建一个新的可调用对象，该对象是通过对给定函数对象、函数指针或成员函数指针的参数进行绑定而生成的。它可以用来部分应用参数或者重新排列参数顺序。例如：
void foo(int a, int b) {
    std::cout << "foo: " << a << ", " << b << std::endl;
}

int main() {
    auto func1 = std::bind(foo, 1, 2);
    func1(); // 调用 foo(1, 2)

    auto func2 = std::bind(foo, std::placeholders::_2, std::placeholders::_1);
    func2(3, 4); // 调用 foo(4, 3)

    return 0;
}
3. std::plus, std::minus, std::multiplies, std::divides
这些函数对象分别对应于加法、减法、乘法和除法操作。它们可以作为参数传递给标准库中的算法，或者在需要函数对象时进行使用。例如：
int main() {
    std::cout << "std::plus(3, 5): " << std::plus<int>()(3, 5) << std::endl;
    std::cout << "std::minus(3, 5): " << std::minus<int>()(3, 5) << std::endl;
    std::cout << "std::multiplies(3, 5): " << std::multiplies<int>()(3, 5) << std::endl;
    std::cout << "std::divides(3, 5): " << std::divides<int>()(3, 5) << std::endl;

    return 0;
}
4. std::greater, std::less
这些函数对象用于比较两个值的大小，分别表示大于和小于的关系。它们可以作为比较函数传递给排序算法等。例如：
int main() {
    std::cout << "std::greater<int>()(3, 5): " << std::greater<int>()(3, 5) << std::endl;
    std::cout << "std::less<int>()(3, 5): " << std::less<int>()(3, 5) << std::endl;

    return 0;
}
5. std::logical_and, std::logical_or, std::logical_not
这些函数对象分别实现逻辑与、逻辑或和逻辑非操作，可以用作逻辑条件的判断。例如：
int main() {
    std::cout << "std::logical_and<bool>()(true, false): " << std::logical_and<bool>()(true, false) << std::endl;
    std::cout << "std::logical_or<bool>()(true, false): " << std::logical_or<bool>()(true, false) << std::endl;
    std::cout << "std::logical_not<bool>()(true): " << std::logical_not<bool>()(true) << std::endl;
    }

总结
C++ 标准库中的 functional 提供了一系列的函数对象，这些对象可以在不同的场景下使用，包括通用的函数封装（std::function）、参数绑定（std::bind）、数学运算（std::plus、std::minus、std::multiplies、std::divides）、比较操作（std::greater、std::less）、逻辑操作（std::logical_and、std::logical_or、std::logical_not）等
1. std::greater<int>()(3, 5) 中的 ()
在 std::greater<int>()(3, 5) 中，std::greater<int>() 是一个函数对象（即仿函数或者说是函数子类型），它用于比较两个值的大小。在 C++ 中，函数对象的对象（实例）可以像函数一样被调用，这是通过重载了函数调用运算符 operator() 实现的。
具体到这个例子，std::greater<int>() 实际上是一个类模板 std::greater 的实例化对象，它接受一个模板参数 int，表示这个函数对象是用来比较 int 类型的值的。当你写 std::greater<int>()(3, 5) 时，实际上是调用了 std::greater<int> 类模板中的 operator()：
template<typename T>
struct greater {
    bool operator()(const T& x, const T& y) const {
        return x > y;
    }
};
这个 operator() 函数接受两个参数 x 和 y，并返回 x > y 的结果，即比较 x 是否大于 y。因此，std::greater<int>()(3, 5) 实际上会返回 false，因为 3 不大于 5。
2. func = [](int x) 中的 []
在 func = [](int x) { ... } 中，[] 是 lambda 表达式的起始标记。Lambda 表达式是 C++11 引入的一种匿名函数的方式，它允许你定义一个可以被调用的匿名函数对象。
Lambda 表达式的一般形式为：
[capture](parameters) -> return_type { body }
[]：这是 lambda 捕获列表（capture list），用于指定在 lambda 表达式中可以使用的外部变量。可以为空（[]），表示不捕获任何外部变量；也可以使用 [&] 或者 [=] 来捕获所有外部变量（引用或者拷贝）。
(parameters)：这里是 lambda 函数的参数列表，类似于普通函数的参数列表。
{ body }：这是 lambda 函数的函数体，里面可以包含一系列的语句，用于执行具体的操作。
例如，对于 func = [](int x) { ... }，它定义了一个 lambda 表达式，该表达式接受一个 int 类型的参数 x，并执行大括号 { ... } 中的操作。


